## Nginx를 사용한 SSL 기반 리버스 프록시 환경의 쿠키 전달

> 이 글은 팀 Ludo의 휴가 작성했습니다.

JWT기반 소셜 로그인 기능을 구현하며 쿠키가 로컬 프론트 단으로 전달되지 않는 이슈가 발생했습니다.

여러 블로그 글과 구글 공식 문서를 크로스 체크하며 확인한 결과 크롬 80 이후부터 적용된 클라이언트 도메인과 서버의 도메인이 일치하지 않아서 발생한 이슈인 것을 확인했습니다.

sameSite 옵션을 꺼야 다른 도메인간 쿠키를 저장할 수 있도록 허용할 수 있고, sameSite 옵션을 끈다면 secure 옵션을 넣어 http를 https로 설정할 필요가 있었습니다.

그러나 sameSite 옵션을 끌 경우 다른 도메인의 서드파티 쿠키 접근이 가능해져, 이로 인한 보안 이슈 발생 가능성이 생기게 됩니다. 따라서 sameSite 옵션을 Strict로 유지하는 방향에서 해결 방안을 고민했고 두 가지 안을 떠올리게 되었습니다.


```
문제 해결을 위해 고민한 방법
1. 서버와 프론트를 모두 배포하여 같은 도메인 부여하기 (도메인 각각 구매)
2. 배포된 서버에 도메인을 부여하고 로컬 프론트의 호스트 주소 변경 및 mkcet를 사용한 SSL 적용 (도메인 하나 구매)      
```

서버와 프론트를 모두 배포하여 같은 도메인을 부여할 경우 가장 간단하게 해결할 수 있지만, 로컬 프론트 환경에서 백엔드 서버와 테스트를 진행할 수 없다는 단점이 발생합니다. 

따라서 배포된 서버에 도메인을 부여하고 로컬 프론트의 호스트 주소 변경 및 mkcet를 사용하여 SSL을 적용하는 방법을 사용하는 것으로 결정했습니다.

하나의 도메인을 가진 리버스 프록시 서버를 앞단에 두고 쿠키를 주고받기 위해 Web-Server 기술 스택을 고민했고 Apache와 Nginx로 후보군을 좁힐 수 있었습니다.

---

### Apache와 Nginx의 차이점

### 1. 설계 아키텍처

#### Apache

- 프로세스 기반 접근 방식 으로 하나의 스레드가 하나의 요청을 처리하는 구조
    
- 매 요청마다 스레드를 생성 및 할당해야 하기 때문에 리소스를 많이 잡아먹음

![image](https://github.com/Ludo-SMP/ludo-backend_wiki/assets/83931353/25aef7e8-dbe6-45f2-8127-46d8f6b1dc4a)

#### Nginx

- 이벤트 중심 접근 방식 으로 하나의 스레드 내에서 여러 요청을 처리하는 구조
    
- 비동기 Event-Driven 구조: Event Handler에서 비동기 방식으로 먼저 처리되는 요청을 진행
    
- 코어 모듈이 Apache보다 적은 리소스로도 많은 트래픽을 효율적으로 처리 가능

![image](https://github.com/Ludo-SMP/ludo-backend_wiki/assets/83931353/a619b0e1-1134-45a0-8bbf-7b33898679a6)

<br>

### 2. 성능

#### 정적 컨텐츠

- 서버 PC의 디스크에 저장하는 파일 기반 방법으로 정적 컨텐츠 제공
    
- 설계 아키텍처 구조상 Nginx가 적은 비용으로 효율적인 서비스 제공
    

#### 동적 컨텐츠

- 두 웹 서버 모두 서버 자체에서 동적 컨텐츠 처리 가능
    
- Nginx는 SCGI 핸들러와 FastCGI 모듈을 사용해서 동적 컨텐츠를 제공할 수 있음
    
- 동적 컨텐츠는 두 웹 서버 성능이 비슷함

<br>

### 3. OS 지원

#### Apache

- Linux 및 BSD를 포함한 모든 Unix 계열 OS 지원
    
- Window 모두 지원
    

#### Nginx

- 거의 모든 Unix 계열 OS 지원
    
- Windows는 부분적으로 지원

<br>

### 4. 분산/중앙 집중식 구성

#### Apache

- .htaccess 파일을 통해 디랙토리 별로 추가 구성을 허용
    
- 이로 인해 권한이 없는 사용자가 웹 사이트의 특정 측면을 제어할 수 있음
    

#### Nginx

- 추가 구성을 허용하지 않음
    
- 권한이 없는 사용자가 웹 사이트의 특정 측면을 제어할 수 없지만 추가 구성을 제공하지 않음으로 성능 향상
    
- 디렉토리 구성을 허용하지 않음으로 .htaccess 파일을 검색하고 사용자가 만든 요구 사항을 해석할 필요 없기 때문에 Apache보다 빠르게 요청을 처리할 수 있음

<br>

### 5. 요청을 처리 및 해석하는 방법의 차이

#### Apache

- 요청을 해석하기 위해 파일 시스템 위치 전달
    
- URI위치를 사용하지만 일반적으로 더 추상적인 디렉토리 구조를 사용
    

#### Nginx

- 요청을 해석하기 위해 URI를 전달
    
- URI로 전달함으로써 웹 서버뿐만 아니라 프록시, 서버, 로드 밸런서 및 HTTP 캐시로 쉽게 동작 가능
    
- 서버에서 클라이언트로 데이터가 전송되는 속도가 Apache 보다 더 빠름

<br>

### 6. 기능 모듈의 차이

#### Apache

- 동적으로 로드 가능한 다양한 60개의 공식 모듈을 제공
    
- 모든 모듈을 가지고 서버가 실행되지만 실제 사용되는 모듈은 소수임 = 무거움
    

#### Nginx

- 타사 플러그인 과정으로 선택되고 컴파일되기 때문에 동적으로 모듈을 로드할 수 없음
    
- 따라서 사용하려는 기능만 선택해서 서버를 실행 = 가벼움

<br>

### 7. 유연성

#### Apache

- 동적 모듈과 로딩을 지원함
    

#### Nginx

- 아직까지는 동적 모듈과 로딩을 지원하지 않음
    
<br>

### 8. 보안

- 두 웹 서버 모두 C언어 기반으로 확장된 보안을 제공함
    
- 하지만 Nginx의 코드가 더 작기 때문에 미래 지향적인 보안 관점에서 장점을 가짐

<br>

### 결론. 그럼 어떤 기술 스택을 적용하지?
### Web-Server 속도 비교
![image](https://github.com/Ludo-SMP/ludo-backend_wiki/assets/83931353/65579c14-c866-4bff-8a5d-c7ca0a9aa00c)

Apache는 .htacess 파일을 제공하기 때문에 이를 활용하거나 Nginx에게 없는 핵심 모듈을 사용할 경우 Apache를 사용하며, 빠른 정적 컨텐츠를 처리하고 싶고 대용량 트래픽을 처리하는 웹 사이트인 경우는 Nginx를 사용하면 된다고 생각했습니다.  
  
저희 서비스의 경우 높은 동시 트래픽을 목표 하고, 필요하다면 로드 밸런싱을 통한 부하 분산도 계획하고 있기에 SSL/TLS 암호화를 지원 및 가볍고 확장 편의성이 높은 Nginx를 적용하는 것으로 결정 했습니다.

---

### Nginx란?

고성능 웹 서버 소프트웨어로, HTTP / HTTPS / TCP 및 UDP 프로토콜을 지원하며, 프록시 서버 / 로드 밸런서 / 역방향 프록시 및 HTTP 캐시 역할을 수행하는데 사용됩니다.

기본 Nginx 설정 파일을 보면 Forward(순방향) Proxy 입니다. Forward Proxy는 경로로 들어오는 경우, root에 지정된 경로에 따라 일치하는 파일로 이동하여 웹에서 내용을 보여줍니다.

하지만, Nginx 서버는 Reverse Proxy 기능을 제공합니다. Forward Proxy와 다르게 외부에서 내부 서버가 제공하는 서비스에 접근할 때, proxy 서버를 먼저 거쳐 내부 서버로 들어오는 방식입니다. 외부 클라이언트는 실제 내부 서버의 존재를 모릅니다.

모든 접속은 Reverse Proxy 서버에 들어오며, Reverse Proxy 서버는 요청에 맵핑되는 서버의 정보에게 요청을 넘겨줍니다. 이처럼 내부 서버의 정보를 외부로부터 숨길 수 있기 때문에 **보안**이 높아집니다.

또, proxy 서버가 내부 서버의 정보를 알고 있으므로 로드 밸런싱을 통해 부하 여부에 따라 요청을 분배할 수 있습니다. proxy 서버를 사용하여 캐싱 기능과 트래픽 분산 기능을 결합시켜 전반적인 서버 성능의 향상 또한 기대할 수 있습니다.

<br>

### Nginx를 도입하여 얻은 이점

### 1. Reverse Proxy를 통한 SameSite Strict 환경의 쿠키 전달
### 2. Web Server와 Web Application Server 의 분리

---

### 아키텍처 구조

![image](https://github.com/Ludo-SMP/ludo-backend_wiki/assets/83931353/f0303ec2-1ea4-42c1-8d2a-542ef038e706)
